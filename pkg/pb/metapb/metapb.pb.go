// Code generated by protoc-gen-gogo.
// source: metapb.proto
// DO NOT EDIT!

/*
	Package metapb is a generated protocol buffer package.

	It is generated from these files:
		metapb.proto

	It has these top-level messages:
		Proxy
		Cluster
		HeathCheck
		CircuitBreaker
		Server
		Bind
		PairValue
		IPAccessControl
		HTTPResult
		Parameter
		ValidationRule
		Validation
		DispatchNode
		Cache
		RenderTemplate
		RenderObject
		RenderAttr
		API
		Condition
		Routing
*/
package metapb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Status is the components status
type Status int32

const (
	Down    Status = 0
	Up      Status = 1
	Unknown Status = 2
)

var Status_name = map[int32]string{
	0: "Down",
	1: "Up",
	2: "Unknown",
}
var Status_value = map[string]int32{
	"Down":    0,
	"Up":      1,
	"Unknown": 2,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

// CircuitStatus is the circuit breaker status
type CircuitStatus int32

const (
	Open  CircuitStatus = 0
	Half  CircuitStatus = 1
	Close CircuitStatus = 2
)

var CircuitStatus_name = map[int32]string{
	0: "Open",
	1: "Half",
	2: "Close",
}
var CircuitStatus_value = map[string]int32{
	"Open":  0,
	"Half":  1,
	"Close": 2,
}

func (x CircuitStatus) Enum() *CircuitStatus {
	p := new(CircuitStatus)
	*p = x
	return p
}
func (x CircuitStatus) String() string {
	return proto.EnumName(CircuitStatus_name, int32(x))
}
func (x *CircuitStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CircuitStatus_value, data, "CircuitStatus")
	if err != nil {
		return err
	}
	*x = CircuitStatus(value)
	return nil
}
func (CircuitStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

// LoadBalance the load balance enum
type LoadBalance int32

const (
	RoundRobin LoadBalance = 0
	IPHash     LoadBalance = 1
)

var LoadBalance_name = map[int32]string{
	0: "RoundRobin",
	1: "IPHash",
}
var LoadBalance_value = map[string]int32{
	"RoundRobin": 0,
	"IPHash":     1,
}

func (x LoadBalance) Enum() *LoadBalance {
	p := new(LoadBalance)
	*p = x
	return p
}
func (x LoadBalance) String() string {
	return proto.EnumName(LoadBalance_name, int32(x))
}
func (x *LoadBalance) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LoadBalance_value, data, "LoadBalance")
	if err != nil {
		return err
	}
	*x = LoadBalance(value)
	return nil
}
func (LoadBalance) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

// Protocol is the protocol of the backend api
type Protocol int32

const (
	HTTP        Protocol = 0
	Grpc        Protocol = 1
	Dubbo       Protocol = 2
	SpringCloud Protocol = 3
)

var Protocol_name = map[int32]string{
	0: "HTTP",
	1: "Grpc",
	2: "Dubbo",
	3: "SpringCloud",
}
var Protocol_value = map[string]int32{
	"HTTP":        0,
	"Grpc":        1,
	"Dubbo":       2,
	"SpringCloud": 3,
}

func (x Protocol) Enum() *Protocol {
	p := new(Protocol)
	*p = x
	return p
}
func (x Protocol) String() string {
	return proto.EnumName(Protocol_name, int32(x))
}
func (x *Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Protocol_value, data, "Protocol")
	if err != nil {
		return err
	}
	*x = Protocol(value)
	return nil
}
func (Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

type Source int32

const (
	QueryString Source = 0
	FormData    Source = 1
	JSONBody    Source = 2
	Header      Source = 3
	Cookie      Source = 4
	PathValue   Source = 5
)

var Source_name = map[int32]string{
	0: "QueryString",
	1: "FormData",
	2: "JSONBody",
	3: "Header",
	4: "Cookie",
	5: "PathValue",
}
var Source_value = map[string]int32{
	"QueryString": 0,
	"FormData":    1,
	"JSONBody":    2,
	"Header":      3,
	"Cookie":      4,
	"PathValue":   5,
}

func (x Source) Enum() *Source {
	p := new(Source)
	*p = x
	return p
}
func (x Source) String() string {
	return proto.EnumName(Source_name, int32(x))
}
func (x *Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Source_value, data, "Source")
	if err != nil {
		return err
	}
	*x = Source(value)
	return nil
}
func (Source) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

type RuleType int32

const (
	RuleRegexp RuleType = 0
)

var RuleType_name = map[int32]string{
	0: "RuleRegexp",
}
var RuleType_value = map[string]int32{
	"RuleRegexp": 0,
}

func (x RuleType) Enum() *RuleType {
	p := new(RuleType)
	*p = x
	return p
}
func (x RuleType) String() string {
	return proto.EnumName(RuleType_name, int32(x))
}
func (x *RuleType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RuleType_value, data, "RuleType")
	if err != nil {
		return err
	}
	*x = RuleType(value)
	return nil
}
func (RuleType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{5} }

type CMP int32

const (
	CMPEQ    CMP = 0
	CMPLT    CMP = 1
	CMPLE    CMP = 2
	CMPGT    CMP = 3
	CMPGE    CMP = 4
	CMPIn    CMP = 5
	CMPMatch CMP = 6
)

var CMP_name = map[int32]string{
	0: "CMPEQ",
	1: "CMPLT",
	2: "CMPLE",
	3: "CMPGT",
	4: "CMPGE",
	5: "CMPIn",
	6: "CMPMatch",
}
var CMP_value = map[string]int32{
	"CMPEQ":    0,
	"CMPLT":    1,
	"CMPLE":    2,
	"CMPGT":    3,
	"CMPGE":    4,
	"CMPIn":    5,
	"CMPMatch": 6,
}

func (x CMP) Enum() *CMP {
	p := new(CMP)
	*p = x
	return p
}
func (x CMP) String() string {
	return proto.EnumName(CMP_name, int32(x))
}
func (x *CMP) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMP_value, data, "CMP")
	if err != nil {
		return err
	}
	*x = CMP(value)
	return nil
}
func (CMP) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{6} }

type RoutingStrategy int32

const (
	Copy  RoutingStrategy = 0
	Split RoutingStrategy = 1
)

var RoutingStrategy_name = map[int32]string{
	0: "Copy",
	1: "Split",
}
var RoutingStrategy_value = map[string]int32{
	"Copy":  0,
	"Split": 1,
}

func (x RoutingStrategy) Enum() *RoutingStrategy {
	p := new(RoutingStrategy)
	*p = x
	return p
}
func (x RoutingStrategy) String() string {
	return proto.EnumName(RoutingStrategy_name, int32(x))
}
func (x *RoutingStrategy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RoutingStrategy_value, data, "RoutingStrategy")
	if err != nil {
		return err
	}
	*x = RoutingStrategy(value)
	return nil
}
func (RoutingStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{7} }

// Proxy is a meta data of the gateway proxy
type Proxy struct {
	Addr             string `protobuf:"bytes,1,opt,name=addr" json:"addr"`
	AddrRPC          string `protobuf:"bytes,2,opt,name=addrRPC" json:"addrRPC"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Proxy) Reset()                    { *m = Proxy{} }
func (m *Proxy) String() string            { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()               {}
func (*Proxy) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

func (m *Proxy) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Proxy) GetAddrRPC() string {
	if m != nil {
		return m.AddrRPC
	}
	return ""
}

// Cluster is a set of server has same interface
type Cluster struct {
	ID               uint64      `protobuf:"varint,1,opt,name=id" json:"id"`
	Name             string      `protobuf:"bytes,2,opt,name=name" json:"name"`
	LoadBalance      LoadBalance `protobuf:"varint,3,opt,name=loadBalance,enum=metapb.LoadBalance" json:"loadBalance"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

func (m *Cluster) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetLoadBalance() LoadBalance {
	if m != nil {
		return m.LoadBalance
	}
	return RoundRobin
}

// HeathCheck is the heath check
type HeathCheck struct {
	Path             string `protobuf:"bytes,1,opt,name=path" json:"path"`
	Body             string `protobuf:"bytes,2,opt,name=body" json:"body"`
	CheckInterval    int64  `protobuf:"varint,3,opt,name=checkInterval" json:"checkInterval"`
	Timeout          int64  `protobuf:"varint,4,opt,name=timeout" json:"timeout"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *HeathCheck) Reset()                    { *m = HeathCheck{} }
func (m *HeathCheck) String() string            { return proto.CompactTextString(m) }
func (*HeathCheck) ProtoMessage()               {}
func (*HeathCheck) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

func (m *HeathCheck) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HeathCheck) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *HeathCheck) GetCheckInterval() int64 {
	if m != nil {
		return m.CheckInterval
	}
	return 0
}

func (m *HeathCheck) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// CircuitBreaker circuit breaker
type CircuitBreaker struct {
	CloseTimeout       int64  `protobuf:"varint,1,opt,name=closeTimeout" json:"closeTimeout"`
	HalfTrafficRate    int32  `protobuf:"varint,2,opt,name=halfTrafficRate" json:"halfTrafficRate"`
	RateCheckPeriod    int64  `protobuf:"varint,3,opt,name=rateCheckPeriod" json:"rateCheckPeriod"`
	FailureRateToClose int32  `protobuf:"varint,4,opt,name=failureRateToClose" json:"failureRateToClose"`
	SucceedRateToOpen  int32  `protobuf:"varint,5,opt,name=succeedRateToOpen" json:"succeedRateToOpen"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *CircuitBreaker) Reset()                    { *m = CircuitBreaker{} }
func (m *CircuitBreaker) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreaker) ProtoMessage()               {}
func (*CircuitBreaker) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

func (m *CircuitBreaker) GetCloseTimeout() int64 {
	if m != nil {
		return m.CloseTimeout
	}
	return 0
}

func (m *CircuitBreaker) GetHalfTrafficRate() int32 {
	if m != nil {
		return m.HalfTrafficRate
	}
	return 0
}

func (m *CircuitBreaker) GetRateCheckPeriod() int64 {
	if m != nil {
		return m.RateCheckPeriod
	}
	return 0
}

func (m *CircuitBreaker) GetFailureRateToClose() int32 {
	if m != nil {
		return m.FailureRateToClose
	}
	return 0
}

func (m *CircuitBreaker) GetSucceedRateToOpen() int32 {
	if m != nil {
		return m.SucceedRateToOpen
	}
	return 0
}

// Server is a backend server that provide api
type Server struct {
	ID               uint64          `protobuf:"varint,1,opt,name=id" json:"id"`
	Addr             string          `protobuf:"bytes,2,opt,name=addr" json:"addr"`
	Protocol         Protocol        `protobuf:"varint,3,opt,name=protocol,enum=metapb.Protocol" json:"protocol"`
	MaxQPS           int64           `protobuf:"varint,4,opt,name=maxQPS" json:"maxQPS"`
	HeathCheck       *HeathCheck     `protobuf:"bytes,5,opt,name=heathCheck" json:"heathCheck,omitempty"`
	CircuitBreaker   *CircuitBreaker `protobuf:"bytes,6,opt,name=circuitBreaker" json:"circuitBreaker,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

func (m *Server) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Server) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Server) GetProtocol() Protocol {
	if m != nil {
		return m.Protocol
	}
	return HTTP
}

func (m *Server) GetMaxQPS() int64 {
	if m != nil {
		return m.MaxQPS
	}
	return 0
}

func (m *Server) GetHeathCheck() *HeathCheck {
	if m != nil {
		return m.HeathCheck
	}
	return nil
}

func (m *Server) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

// Bind is a bind pair with cluster and server
type Bind struct {
	ClusterID        uint64 `protobuf:"varint,1,opt,name=clusterID" json:"clusterID"`
	ServerID         uint64 `protobuf:"varint,2,opt,name=serverID" json:"serverID"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Bind) Reset()                    { *m = Bind{} }
func (m *Bind) String() string            { return proto.CompactTextString(m) }
func (*Bind) ProtoMessage()               {}
func (*Bind) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{5} }

func (m *Bind) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Bind) GetServerID() uint64 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

// Pair is pair value
type PairValue struct {
	Name             string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value            string `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PairValue) Reset()                    { *m = PairValue{} }
func (m *PairValue) String() string            { return proto.CompactTextString(m) }
func (*PairValue) ProtoMessage()               {}
func (*PairValue) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{6} }

func (m *PairValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PairValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPAccessControl is for ip access control
type IPAccessControl struct {
	Whitelist        []string `protobuf:"bytes,1,rep,name=whitelist" json:"whitelist,omitempty"`
	Blacklist        []string `protobuf:"bytes,2,rep,name=blacklist" json:"blacklist,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *IPAccessControl) Reset()                    { *m = IPAccessControl{} }
func (m *IPAccessControl) String() string            { return proto.CompactTextString(m) }
func (*IPAccessControl) ProtoMessage()               {}
func (*IPAccessControl) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{7} }

func (m *IPAccessControl) GetWhitelist() []string {
	if m != nil {
		return m.Whitelist
	}
	return nil
}

func (m *IPAccessControl) GetBlacklist() []string {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

// HTTPResult is a http result
type HTTPResult struct {
	Body             []byte       `protobuf:"bytes,1,opt,name=body" json:"body,omitempty"`
	Headers          []*PairValue `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	Cookies          []*PairValue `protobuf:"bytes,3,rep,name=cookies" json:"cookies,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *HTTPResult) Reset()                    { *m = HTTPResult{} }
func (m *HTTPResult) String() string            { return proto.CompactTextString(m) }
func (*HTTPResult) ProtoMessage()               {}
func (*HTTPResult) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{8} }

func (m *HTTPResult) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *HTTPResult) GetHeaders() []*PairValue {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HTTPResult) GetCookies() []*PairValue {
	if m != nil {
		return m.Cookies
	}
	return nil
}

// Parameter is a parameter from a http request
type Parameter struct {
	Name             string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Source           Source `protobuf:"varint,2,opt,name=source,enum=metapb.Source" json:"source"`
	Index            int32  `protobuf:"varint,3,opt,name=index" json:"index"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{9} }

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetSource() Source {
	if m != nil {
		return m.Source
	}
	return QueryString
}

func (m *Parameter) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

// ValidationRule is a validation rule
type ValidationRule struct {
	RuleType         RuleType `protobuf:"varint,1,opt,name=ruleType,enum=metapb.RuleType" json:"ruleType"`
	Expression       string   `protobuf:"bytes,2,opt,name=expression" json:"expression"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ValidationRule) Reset()                    { *m = ValidationRule{} }
func (m *ValidationRule) String() string            { return proto.CompactTextString(m) }
func (*ValidationRule) ProtoMessage()               {}
func (*ValidationRule) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{10} }

func (m *ValidationRule) GetRuleType() RuleType {
	if m != nil {
		return m.RuleType
	}
	return RuleRegexp
}

func (m *ValidationRule) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

// Validation is a validation
type Validation struct {
	Parameter        Parameter        `protobuf:"bytes,1,opt,name=parameter" json:"parameter"`
	Required         bool             `protobuf:"varint,2,opt,name=required" json:"required"`
	Rules            []ValidationRule `protobuf:"bytes,3,rep,name=rules" json:"rules"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Validation) Reset()                    { *m = Validation{} }
func (m *Validation) String() string            { return proto.CompactTextString(m) }
func (*Validation) ProtoMessage()               {}
func (*Validation) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{11} }

func (m *Validation) GetParameter() Parameter {
	if m != nil {
		return m.Parameter
	}
	return Parameter{}
}

func (m *Validation) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *Validation) GetRules() []ValidationRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// DispatchNode is the request forward to
type DispatchNode struct {
	ClusterID        uint64        `protobuf:"varint,1,opt,name=clusterID" json:"clusterID"`
	URLRewrite       string        `protobuf:"bytes,2,opt,name=urlRewrite" json:"urlRewrite"`
	AttrName         string        `protobuf:"bytes,3,opt,name=attrName" json:"attrName"`
	Validations      []*Validation `protobuf:"bytes,4,rep,name=validations" json:"validations,omitempty"`
	Cache            *Cache        `protobuf:"bytes,5,opt,name=cache" json:"cache,omitempty"`
	DefaultValue     *HTTPResult   `protobuf:"bytes,6,opt,name=defaultValue" json:"defaultValue,omitempty"`
	UseDefault       bool          `protobuf:"varint,7,opt,name=useDefault" json:"useDefault"`
	BatchIndex       int32         `protobuf:"varint,8,opt,name=batchIndex" json:"batchIndex"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *DispatchNode) Reset()                    { *m = DispatchNode{} }
func (m *DispatchNode) String() string            { return proto.CompactTextString(m) }
func (*DispatchNode) ProtoMessage()               {}
func (*DispatchNode) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{12} }

func (m *DispatchNode) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *DispatchNode) GetURLRewrite() string {
	if m != nil {
		return m.URLRewrite
	}
	return ""
}

func (m *DispatchNode) GetAttrName() string {
	if m != nil {
		return m.AttrName
	}
	return ""
}

func (m *DispatchNode) GetValidations() []*Validation {
	if m != nil {
		return m.Validations
	}
	return nil
}

func (m *DispatchNode) GetCache() *Cache {
	if m != nil {
		return m.Cache
	}
	return nil
}

func (m *DispatchNode) GetDefaultValue() *HTTPResult {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *DispatchNode) GetUseDefault() bool {
	if m != nil {
		return m.UseDefault
	}
	return false
}

func (m *DispatchNode) GetBatchIndex() int32 {
	if m != nil {
		return m.BatchIndex
	}
	return 0
}

// Cache is used for cache api result
type Cache struct {
	Keys             []Parameter `protobuf:"bytes,1,rep,name=keys" json:"keys"`
	Deadline         uint64      `protobuf:"varint,2,opt,name=deadline" json:"deadline"`
	Conditions       []Condition `protobuf:"bytes,3,rep,name=conditions" json:"conditions"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Cache) Reset()                    { *m = Cache{} }
func (m *Cache) String() string            { return proto.CompactTextString(m) }
func (*Cache) ProtoMessage()               {}
func (*Cache) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{13} }

func (m *Cache) GetKeys() []Parameter {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Cache) GetDeadline() uint64 {
	if m != nil {
		return m.Deadline
	}
	return 0
}

func (m *Cache) GetConditions() []Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// RenderTemplate the template that render to client
type RenderTemplate struct {
	Objects          []*RenderObject `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *RenderTemplate) Reset()                    { *m = RenderTemplate{} }
func (m *RenderTemplate) String() string            { return proto.CompactTextString(m) }
func (*RenderTemplate) ProtoMessage()               {}
func (*RenderTemplate) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{14} }

func (m *RenderTemplate) GetObjects() []*RenderObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

// RenderObject the object in the render template
type RenderObject struct {
	Name             string        `protobuf:"bytes,1,opt,name=name" json:"name"`
	Attrs            []*RenderAttr `protobuf:"bytes,2,rep,name=attrs" json:"attrs,omitempty"`
	FlatAttrs        bool          `protobuf:"varint,3,opt,name=flatAttrs" json:"flatAttrs"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *RenderObject) Reset()                    { *m = RenderObject{} }
func (m *RenderObject) String() string            { return proto.CompactTextString(m) }
func (*RenderObject) ProtoMessage()               {}
func (*RenderObject) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{15} }

func (m *RenderObject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RenderObject) GetAttrs() []*RenderAttr {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *RenderObject) GetFlatAttrs() bool {
	if m != nil {
		return m.FlatAttrs
	}
	return false
}

// RenderAttr the attr in the render object
type RenderAttr struct {
	Name             string `protobuf:"bytes,1,opt,name=name" json:"name"`
	ExtractExp       string `protobuf:"bytes,2,opt,name=extractExp" json:"extractExp"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RenderAttr) Reset()                    { *m = RenderAttr{} }
func (m *RenderAttr) String() string            { return proto.CompactTextString(m) }
func (*RenderAttr) ProtoMessage()               {}
func (*RenderAttr) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{16} }

func (m *RenderAttr) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RenderAttr) GetExtractExp() string {
	if m != nil {
		return m.ExtractExp
	}
	return ""
}

// API is the api for dispatcher
type API struct {
	ID               uint64           `protobuf:"varint,1,opt,name=id" json:"id"`
	Name             string           `protobuf:"bytes,2,opt,name=name" json:"name"`
	URLPattern       string           `protobuf:"bytes,3,opt,name=urlPattern" json:"urlPattern"`
	Method           string           `protobuf:"bytes,4,opt,name=method" json:"method"`
	Domain           string           `protobuf:"bytes,5,opt,name=domain" json:"domain"`
	Status           Status           `protobuf:"varint,6,opt,name=status,enum=metapb.Status" json:"status"`
	IPAccessControl  *IPAccessControl `protobuf:"bytes,7,opt,name=ipAccessControl" json:"ipAccessControl,omitempty"`
	DefaultValue     *HTTPResult      `protobuf:"bytes,8,opt,name=defaultValue" json:"defaultValue,omitempty"`
	Nodes            []*DispatchNode  `protobuf:"bytes,9,rep,name=nodes" json:"nodes,omitempty"`
	Perms            []string         `protobuf:"bytes,10,rep,name=perms" json:"perms,omitempty"`
	AuthFilter       string           `protobuf:"bytes,11,opt,name=authFilter" json:"authFilter"`
	RenderTemplate   *RenderTemplate  `protobuf:"bytes,12,opt,name=renderTemplate" json:"renderTemplate,omitempty"`
	UseDefault       bool             `protobuf:"varint,13,opt,name=useDefault" json:"useDefault"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *API) Reset()                    { *m = API{} }
func (m *API) String() string            { return proto.CompactTextString(m) }
func (*API) ProtoMessage()               {}
func (*API) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{17} }

func (m *API) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *API) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *API) GetURLPattern() string {
	if m != nil {
		return m.URLPattern
	}
	return ""
}

func (m *API) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *API) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *API) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func (m *API) GetIPAccessControl() *IPAccessControl {
	if m != nil {
		return m.IPAccessControl
	}
	return nil
}

func (m *API) GetDefaultValue() *HTTPResult {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *API) GetNodes() []*DispatchNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *API) GetPerms() []string {
	if m != nil {
		return m.Perms
	}
	return nil
}

func (m *API) GetAuthFilter() string {
	if m != nil {
		return m.AuthFilter
	}
	return ""
}

func (m *API) GetRenderTemplate() *RenderTemplate {
	if m != nil {
		return m.RenderTemplate
	}
	return nil
}

func (m *API) GetUseDefault() bool {
	if m != nil {
		return m.UseDefault
	}
	return false
}

// Condition is a condition for routing
type Condition struct {
	Parameter        Parameter `protobuf:"bytes,1,opt,name=parameter" json:"parameter"`
	Cmp              CMP       `protobuf:"varint,2,opt,name=cmp,enum=metapb.CMP" json:"cmp"`
	Expect           string    `protobuf:"bytes,3,opt,name=expect" json:"expect"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Condition) Reset()                    { *m = Condition{} }
func (m *Condition) String() string            { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()               {}
func (*Condition) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{18} }

func (m *Condition) GetParameter() Parameter {
	if m != nil {
		return m.Parameter
	}
	return Parameter{}
}

func (m *Condition) GetCmp() CMP {
	if m != nil {
		return m.Cmp
	}
	return CMPEQ
}

func (m *Condition) GetExpect() string {
	if m != nil {
		return m.Expect
	}
	return ""
}

// Routing is a routing
type Routing struct {
	ID               uint64          `protobuf:"varint,1,opt,name=id" json:"id"`
	ClusterID        uint64          `protobuf:"varint,2,opt,name=clusterID" json:"clusterID"`
	Conditions       []Condition     `protobuf:"bytes,3,rep,name=conditions" json:"conditions"`
	Strategy         RoutingStrategy `protobuf:"varint,4,opt,name=strategy,enum=metapb.RoutingStrategy" json:"strategy"`
	TrafficRate      int32           `protobuf:"varint,5,opt,name=trafficRate" json:"trafficRate"`
	Status           Status          `protobuf:"varint,6,opt,name=status,enum=metapb.Status" json:"status"`
	API              uint64          `protobuf:"varint,7,opt,name=api" json:"api"`
	Name             string          `protobuf:"bytes,8,opt,name=name" json:"name"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Routing) Reset()                    { *m = Routing{} }
func (m *Routing) String() string            { return proto.CompactTextString(m) }
func (*Routing) ProtoMessage()               {}
func (*Routing) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{19} }

func (m *Routing) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Routing) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Routing) GetConditions() []Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Routing) GetStrategy() RoutingStrategy {
	if m != nil {
		return m.Strategy
	}
	return Copy
}

func (m *Routing) GetTrafficRate() int32 {
	if m != nil {
		return m.TrafficRate
	}
	return 0
}

func (m *Routing) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func (m *Routing) GetAPI() uint64 {
	if m != nil {
		return m.API
	}
	return 0
}

func (m *Routing) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*Proxy)(nil), "metapb.Proxy")
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*HeathCheck)(nil), "metapb.HeathCheck")
	proto.RegisterType((*CircuitBreaker)(nil), "metapb.CircuitBreaker")
	proto.RegisterType((*Server)(nil), "metapb.Server")
	proto.RegisterType((*Bind)(nil), "metapb.Bind")
	proto.RegisterType((*PairValue)(nil), "metapb.PairValue")
	proto.RegisterType((*IPAccessControl)(nil), "metapb.IPAccessControl")
	proto.RegisterType((*HTTPResult)(nil), "metapb.HTTPResult")
	proto.RegisterType((*Parameter)(nil), "metapb.Parameter")
	proto.RegisterType((*ValidationRule)(nil), "metapb.ValidationRule")
	proto.RegisterType((*Validation)(nil), "metapb.Validation")
	proto.RegisterType((*DispatchNode)(nil), "metapb.DispatchNode")
	proto.RegisterType((*Cache)(nil), "metapb.Cache")
	proto.RegisterType((*RenderTemplate)(nil), "metapb.RenderTemplate")
	proto.RegisterType((*RenderObject)(nil), "metapb.RenderObject")
	proto.RegisterType((*RenderAttr)(nil), "metapb.RenderAttr")
	proto.RegisterType((*API)(nil), "metapb.API")
	proto.RegisterType((*Condition)(nil), "metapb.Condition")
	proto.RegisterType((*Routing)(nil), "metapb.Routing")
	proto.RegisterEnum("metapb.Status", Status_name, Status_value)
	proto.RegisterEnum("metapb.CircuitStatus", CircuitStatus_name, CircuitStatus_value)
	proto.RegisterEnum("metapb.LoadBalance", LoadBalance_name, LoadBalance_value)
	proto.RegisterEnum("metapb.Protocol", Protocol_name, Protocol_value)
	proto.RegisterEnum("metapb.Source", Source_name, Source_value)
	proto.RegisterEnum("metapb.RuleType", RuleType_name, RuleType_value)
	proto.RegisterEnum("metapb.CMP", CMP_name, CMP_value)
	proto.RegisterEnum("metapb.RoutingStrategy", RoutingStrategy_name, RoutingStrategy_value)
}
func (m *Proxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
	i += copy(dAtA[i:], m.Addr)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AddrRPC)))
	i += copy(dAtA[i:], m.AddrRPC)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.LoadBalance))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeathCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeathCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Body)))
	i += copy(dAtA[i:], m.Body)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.CheckInterval))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Timeout))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CircuitBreaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitBreaker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.CloseTimeout))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.HalfTrafficRate))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RateCheckPeriod))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.FailureRateToClose))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.SucceedRateToOpen))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Server) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
	i += copy(dAtA[i:], m.Addr)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Protocol))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.MaxQPS))
	if m.HeathCheck != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.HeathCheck.Size()))
		n1, err := m.HeathCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CircuitBreaker != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CircuitBreaker.Size()))
		n2, err := m.CircuitBreaker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ServerID))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PairValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PairValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IPAccessControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAccessControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cookies) > 0 {
		for _, msg := range m.Cookies {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Source))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Index))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidationRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RuleType))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expression)))
	i += copy(dAtA[i:], m.Expression)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Validation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Parameter.Size()))
	n3, err := m.Parameter.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x10
	i++
	if m.Required {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DispatchNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.URLRewrite)))
	i += copy(dAtA[i:], m.URLRewrite)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AttrName)))
	i += copy(dAtA[i:], m.AttrName)
	if len(m.Validations) > 0 {
		for _, msg := range m.Validations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cache != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Cache.Size()))
		n4, err := m.Cache.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DefaultValue.Size()))
		n5, err := m.DefaultValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	dAtA[i] = 0x38
	i++
	if m.UseDefault {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.BatchIndex))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cache) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Deadline))
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenderTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderTemplate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenderObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Attrs) > 0 {
		for _, msg := range m.Attrs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	if m.FlatAttrs {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenderAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderAttr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.ExtractExp)))
	i += copy(dAtA[i:], m.ExtractExp)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *API) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *API) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.URLPattern)))
	i += copy(dAtA[i:], m.URLPattern)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Method)))
	i += copy(dAtA[i:], m.Method)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	if m.IPAccessControl != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.IPAccessControl.Size()))
		n6, err := m.IPAccessControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DefaultValue.Size()))
		n7, err := m.DefaultValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Perms) > 0 {
		for _, s := range m.Perms {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AuthFilter)))
	i += copy(dAtA[i:], m.AuthFilter)
	if m.RenderTemplate != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RenderTemplate.Size()))
		n8, err := m.RenderTemplate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	dAtA[i] = 0x68
	i++
	if m.UseDefault {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Parameter.Size()))
	n9, err := m.Parameter.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Cmp))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expect)))
	i += copy(dAtA[i:], m.Expect)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Routing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Routing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Strategy))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.TrafficRate))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x38
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.API))
	dAtA[i] = 0x42
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Metapb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Metapb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Proxy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.AddrRPC)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.LoadBalance))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeathCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Body)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.CheckInterval))
	n += 1 + sovMetapb(uint64(m.Timeout))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CircuitBreaker) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.CloseTimeout))
	n += 1 + sovMetapb(uint64(m.HalfTrafficRate))
	n += 1 + sovMetapb(uint64(m.RateCheckPeriod))
	n += 1 + sovMetapb(uint64(m.FailureRateToClose))
	n += 1 + sovMetapb(uint64(m.SucceedRateToOpen))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Server) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Addr)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Protocol))
	n += 1 + sovMetapb(uint64(m.MaxQPS))
	if m.HeathCheck != nil {
		l = m.HeathCheck.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bind) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ClusterID))
	n += 1 + sovMetapb(uint64(m.ServerID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PairValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPAccessControl) Size() (n int) {
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPResult) Size() (n int) {
	var l int
	_ = l
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Cookies) > 0 {
		for _, e := range m.Cookies {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Parameter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Source))
	n += 1 + sovMetapb(uint64(m.Index))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidationRule) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.RuleType))
	l = len(m.Expression)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Validation) Size() (n int) {
	var l int
	_ = l
	l = m.Parameter.Size()
	n += 1 + l + sovMetapb(uint64(l))
	n += 2
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DispatchNode) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ClusterID))
	l = len(m.URLRewrite)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.AttrName)
	n += 1 + l + sovMetapb(uint64(l))
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Cache != nil {
		l = m.Cache.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	n += 2
	n += 1 + sovMetapb(uint64(m.BatchIndex))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cache) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 1 + sovMetapb(uint64(m.Deadline))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderTemplate) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderObject) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderAttr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.ExtractExp)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *API) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.URLPattern)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Method)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Status))
	if m.IPAccessControl != nil {
		l = m.IPAccessControl.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Perms) > 0 {
		for _, s := range m.Perms {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	l = len(m.AuthFilter)
	n += 1 + l + sovMetapb(uint64(l))
	if m.RenderTemplate != nil {
		l = m.RenderTemplate.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	var l int
	_ = l
	l = m.Parameter.Size()
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Cmp))
	l = len(m.Expect)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Routing) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	n += 1 + sovMetapb(uint64(m.ClusterID))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 1 + sovMetapb(uint64(m.Strategy))
	n += 1 + sovMetapb(uint64(m.TrafficRate))
	n += 1 + sovMetapb(uint64(m.Status))
	n += 1 + sovMetapb(uint64(m.API))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Proxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalance", wireType)
			}
			m.LoadBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalance |= (LoadBalance(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeathCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeathCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeathCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckInterval", wireType)
			}
			m.CheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitBreaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitBreaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitBreaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTimeout", wireType)
			}
			m.CloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTimeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalfTrafficRate", wireType)
			}
			m.HalfTrafficRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HalfTrafficRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateCheckPeriod", wireType)
			}
			m.RateCheckPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateCheckPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureRateToClose", wireType)
			}
			m.FailureRateToClose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureRateToClose |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceedRateToOpen", wireType)
			}
			m.SucceedRateToOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SucceedRateToOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQPS", wireType)
			}
			m.MaxQPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQPS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeathCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeathCheck == nil {
				m.HeathCheck = &HeathCheck{}
			}
			if err := m.HeathCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PairValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PairValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PairValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAccessControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAccessControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAccessControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whitelist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Whitelist = append(m.Whitelist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blacklist = append(m.Blacklist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &PairValue{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookies = append(m.Cookies, &PairValue{})
			if err := m.Cookies[len(m.Cookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (Source(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleType", wireType)
			}
			m.RuleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleType |= (RuleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, ValidationRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLRewrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, &Validation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cache == nil {
				m.Cache = &Cache{}
			}
			if err := m.Cache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &HTTPResult{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseDefault = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
			m.BatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, Parameter{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &RenderObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &RenderAttr{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatAttrs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlatAttrs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtractExp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtractExp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *API) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: API: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: API: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLPattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLPattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAccessControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAccessControl == nil {
				m.IPAccessControl = &IPAccessControl{}
			}
			if err := m.IPAccessControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &HTTPResult{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &DispatchNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Perms = append(m.Perms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenderTemplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RenderTemplate == nil {
				m.RenderTemplate = &RenderTemplate{}
			}
			if err := m.RenderTemplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseDefault = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmp", wireType)
			}
			m.Cmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmp |= (CMP(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Routing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Routing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Routing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= (RoutingStrategy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficRate", wireType)
			}
			m.TrafficRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field API", wireType)
			}
			m.API = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.API |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("metapb.proto", fileDescriptorMetapb) }

var fileDescriptorMetapb = []byte{
	// 1581 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4f, 0x6f, 0xdb, 0x46,
	0x16, 0x17, 0xa9, 0x3f, 0x96, 0x9e, 0x64, 0x99, 0x99, 0x35, 0x36, 0x82, 0xb1, 0xeb, 0x04, 0xcc,
	0x22, 0xeb, 0x55, 0x16, 0x5e, 0x40, 0xc8, 0x62, 0xb1, 0x6d, 0x51, 0xd4, 0x92, 0x9c, 0x58, 0x85,
	0x9d, 0x30, 0x94, 0x9c, 0x43, 0xd1, 0xcb, 0x88, 0x1c, 0x5b, 0x8c, 0x29, 0x0e, 0x3b, 0x1c, 0x3a,
	0x56, 0xd1, 0x63, 0x7b, 0x2b, 0xd0, 0x6b, 0xfb, 0x71, 0x7a, 0xcb, 0xa1, 0x87, 0x7c, 0x82, 0xa0,
	0x75, 0xcf, 0xfd, 0x0e, 0xc5, 0x0c, 0x87, 0x14, 0x29, 0x3b, 0x6e, 0x93, 0x93, 0x86, 0xbf, 0xf7,
	0x9b, 0x99, 0x37, 0x6f, 0x7e, 0xef, 0xcd, 0x13, 0xb4, 0xe6, 0x84, 0xe3, 0x70, 0xba, 0x1b, 0x32,
	0xca, 0x29, 0xaa, 0x25, 0x5f, 0x5b, 0x9b, 0xa7, 0xf4, 0x94, 0x4a, 0xe8, 0x3f, 0x62, 0x94, 0x58,
	0xcd, 0x3d, 0xa8, 0x5a, 0x8c, 0x5e, 0x2c, 0x50, 0x07, 0x2a, 0xd8, 0x75, 0x59, 0x47, 0xbb, 0xab,
	0xed, 0x34, 0xfa, 0x95, 0x57, 0x6f, 0xee, 0x94, 0x6c, 0x89, 0xa0, 0x6d, 0x58, 0x13, 0xbf, 0xb6,
	0x35, 0xe8, 0xe8, 0x39, 0x63, 0x0a, 0x9a, 0x5f, 0xc1, 0xda, 0xc0, 0x8f, 0x23, 0x4e, 0x18, 0xda,
	0x02, 0xdd, 0x73, 0xe5, 0x12, 0x95, 0x3e, 0x08, 0xd6, 0xe5, 0x9b, 0x3b, 0xfa, 0x68, 0x68, 0xeb,
	0x9e, 0x2b, 0x36, 0x08, 0xf0, 0x9c, 0x14, 0xd6, 0x90, 0x08, 0xfa, 0x10, 0x9a, 0x3e, 0xc5, 0x6e,
	0x1f, 0xfb, 0x38, 0x70, 0x48, 0xa7, 0x7c, 0x57, 0xdb, 0x69, 0xf7, 0xfe, 0xb2, 0xab, 0x4e, 0x71,
	0xb8, 0x34, 0xa9, 0x59, 0x79, 0xb6, 0xf9, 0xad, 0x06, 0x70, 0x40, 0x30, 0x9f, 0x0d, 0x66, 0xc4,
	0x39, 0x13, 0xbb, 0x84, 0x98, 0xcf, 0x8a, 0xc7, 0x10, 0x88, 0xb0, 0x4c, 0xa9, 0xbb, 0x28, 0xee,
	0x2f, 0x10, 0xd4, 0x85, 0x75, 0x47, 0x4c, 0x1e, 0x05, 0x9c, 0xb0, 0x73, 0xec, 0x4b, 0x0f, 0xca,
	0x8a, 0x52, 0x34, 0x89, 0x60, 0x70, 0x6f, 0x4e, 0x68, 0xcc, 0x3b, 0x95, 0x1c, 0x2b, 0x05, 0xcd,
	0xaf, 0x75, 0x68, 0x0f, 0x3c, 0xe6, 0xc4, 0x1e, 0xef, 0x33, 0x82, 0xcf, 0x08, 0x43, 0x3b, 0xd0,
	0x72, 0x7c, 0x1a, 0x91, 0x89, 0x9a, 0xa7, 0xe5, 0xe6, 0x15, 0x2c, 0x68, 0x17, 0x36, 0x66, 0xd8,
	0x3f, 0x99, 0x30, 0x7c, 0x72, 0xe2, 0x39, 0x36, 0xe6, 0x49, 0xb4, 0xaa, 0x8a, 0xbc, 0x6a, 0x14,
	0x7c, 0x86, 0x39, 0x91, 0x27, 0xb7, 0x08, 0xf3, 0xa8, 0x5b, 0x70, 0x7d, 0xd5, 0x88, 0x1e, 0x02,
	0x3a, 0xc1, 0x9e, 0x1f, 0x33, 0x22, 0xa6, 0x4f, 0xe8, 0x40, 0x6c, 0x2e, 0xcf, 0x91, 0x6e, 0x71,
	0x8d, 0x1d, 0xf5, 0xe0, 0x56, 0x14, 0x3b, 0x0e, 0x21, 0x6e, 0x82, 0x3e, 0x0d, 0x49, 0xd0, 0xa9,
	0xe6, 0x26, 0x5d, 0x35, 0x8b, 0x30, 0xd4, 0xc6, 0x84, 0x9d, 0xff, 0xb1, 0x26, 0xa4, 0xe8, 0xf4,
	0x2b, 0xa2, 0xeb, 0x41, 0x5d, 0x0a, 0xd4, 0xa1, 0xbe, 0x12, 0x84, 0x91, 0x0a, 0xc2, 0x52, 0xb8,
	0xe2, 0x67, 0x3c, 0xf4, 0x37, 0xa8, 0xcd, 0xf1, 0xc5, 0x33, 0x6b, 0x5c, 0xb8, 0x1a, 0x85, 0xa1,
	0x1e, 0xc0, 0x2c, 0xd3, 0x89, 0xf4, 0xbf, 0xd9, 0x43, 0xe9, 0x9a, 0x4b, 0x05, 0xd9, 0x39, 0x16,
	0xfa, 0x18, 0xda, 0x4e, 0xe1, 0x32, 0x3b, 0x35, 0x39, 0xef, 0xaf, 0xe9, 0xbc, 0xe2, 0x55, 0xdb,
	0x2b, 0x6c, 0xf3, 0x10, 0x2a, 0x7d, 0x2f, 0x70, 0x91, 0x09, 0x0d, 0x27, 0x49, 0x91, 0xd1, 0x50,
	0x85, 0x22, 0x71, 0x6e, 0x09, 0xa3, 0xbb, 0x50, 0x8f, 0x64, 0xc4, 0x46, 0x43, 0x19, 0x8f, 0x94,
	0x92, 0xa1, 0xe6, 0x1e, 0x34, 0x2c, 0xec, 0xb1, 0xe7, 0xd8, 0x8f, 0x49, 0x96, 0x4e, 0xda, 0x95,
	0x74, 0xda, 0x82, 0xea, 0xb9, 0xa0, 0x14, 0xa2, 0x9a, 0x40, 0xe6, 0x11, 0x6c, 0x8c, 0xac, 0x3d,
	0xc7, 0x21, 0x51, 0x34, 0xa0, 0x01, 0x67, 0x32, 0x6a, 0x8d, 0x97, 0x33, 0x8f, 0x13, 0xdf, 0x8b,
	0x84, 0x36, 0xcb, 0x3b, 0x0d, 0x7b, 0x09, 0x08, 0xeb, 0xd4, 0xc7, 0xce, 0x99, 0xb4, 0xea, 0x89,
	0x35, 0x03, 0xcc, 0x2f, 0x01, 0x0e, 0x26, 0x13, 0xcb, 0x26, 0x51, 0xec, 0x73, 0x84, 0x54, 0x86,
	0x09, 0x97, 0x5a, 0x2a, 0xb7, 0x1e, 0xc0, 0xda, 0x8c, 0x60, 0x97, 0xb0, 0x48, 0xce, 0x6e, 0xf6,
	0x6e, 0x65, 0xd7, 0x98, 0x1e, 0xc5, 0x4e, 0x19, 0x82, 0xec, 0x50, 0x7a, 0xe6, 0x91, 0xa8, 0x53,
	0x7e, 0x2b, 0x59, 0x31, 0x4c, 0x2a, 0xa2, 0xc1, 0xf0, 0x9c, 0x88, 0xc2, 0xf3, 0xf6, 0x68, 0xfc,
	0x1b, 0x6a, 0x11, 0x8d, 0x99, 0x93, 0x84, 0xa3, 0xdd, 0x6b, 0xa7, 0x4b, 0x8e, 0x25, 0x9a, 0x8a,
	0x24, 0xe1, 0x88, 0xd8, 0x79, 0x81, 0x4b, 0x2e, 0xa4, 0xe6, 0x52, 0x7d, 0x27, 0x90, 0xf9, 0x02,
	0xda, 0xcf, 0xb1, 0xef, 0xb9, 0x98, 0x7b, 0x34, 0xb0, 0x63, 0x5f, 0x64, 0x46, 0x9d, 0xc5, 0x3e,
	0x99, 0x2c, 0xc2, 0x64, 0xe7, 0x9c, 0x48, 0x6d, 0x85, 0xa7, 0x97, 0x98, 0xf2, 0xd0, 0x3f, 0x00,
	0xc8, 0x45, 0xc8, 0x48, 0x14, 0x79, 0x34, 0x28, 0x5c, 0x51, 0x0e, 0x37, 0x7f, 0xd0, 0x00, 0x96,
	0x9b, 0xa1, 0xff, 0x42, 0x23, 0x4c, 0xcf, 0x2a, 0x77, 0x2a, 0x84, 0x46, 0x19, 0x52, 0x49, 0x65,
	0x4c, 0x21, 0x29, 0x46, 0xbe, 0x88, 0x3d, 0x46, 0x5c, 0xb9, 0x53, 0x3d, 0xf3, 0x46, 0xa1, 0xa8,
	0x07, 0x55, 0xe1, 0x59, 0x1a, 0xef, 0x4c, 0xd7, 0xc5, 0x83, 0xa6, 0x71, 0x90, 0x54, 0xf3, 0x37,
	0x1d, 0x5a, 0x43, 0x2f, 0x0a, 0x31, 0x77, 0x66, 0x4f, 0xa8, 0x4b, 0xfe, 0x94, 0xba, 0x7b, 0x00,
	0x31, 0xf3, 0x6d, 0xf2, 0x92, 0x79, 0x3c, 0x55, 0x26, 0x52, 0xd5, 0x00, 0x8e, 0xed, 0x43, 0x65,
	0xb1, 0x73, 0x2c, 0xe1, 0x3e, 0xe6, 0x9c, 0x3d, 0x11, 0x17, 0x5b, 0xce, 0x05, 0x2a, 0x43, 0xd1,
	0x43, 0x68, 0x9e, 0x67, 0x9e, 0x46, 0x9d, 0x8a, 0x3c, 0x04, 0xba, 0xe6, 0x10, 0x79, 0x1a, 0xba,
	0x07, 0x55, 0x07, 0x3b, 0x33, 0xa2, 0x8a, 0xc0, 0x7a, 0x96, 0xcc, 0x02, 0xb4, 0x13, 0x1b, 0xfa,
	0x08, 0x5a, 0x2e, 0x39, 0xc1, 0xb1, 0xcf, 0xa5, 0xee, 0x54, 0xe2, 0x2f, 0x0b, 0x46, 0x26, 0x7b,
	0xe9, 0x94, 0x66, 0x17, 0xd8, 0xe2, 0x96, 0xe3, 0x88, 0x0c, 0x13, 0xa8, 0xb3, 0x96, 0x8b, 0x7d,
	0x0e, 0x17, 0xac, 0xa9, 0x88, 0xe2, 0x48, 0x4a, 0xae, 0x9e, 0x93, 0x5c, 0x0e, 0x37, 0xbf, 0xd3,
	0xa0, 0x2a, 0x5d, 0x43, 0x0f, 0xa0, 0x72, 0x46, 0x16, 0x91, 0xcc, 0xd2, 0x1b, 0x14, 0x20, 0x49,
	0x22, 0x7a, 0x2e, 0xc1, 0xae, 0xef, 0x05, 0xa4, 0x58, 0x4f, 0x52, 0x14, 0xfd, 0x0f, 0xc0, 0xa1,
	0x81, 0xeb, 0x25, 0xc1, 0x5b, 0xc9, 0xb8, 0x41, 0x6a, 0x49, 0x3d, 0x5a, 0x52, 0xcd, 0x4f, 0xa0,
	0x6d, 0x93, 0xc0, 0x25, 0x6c, 0x42, 0xe6, 0xa1, 0x9f, 0xbc, 0x44, 0x6b, 0x74, 0xfa, 0x82, 0x38,
	0x3c, 0x75, 0x6e, 0x33, 0x4b, 0x04, 0x49, 0x7c, 0x2a, 0x8d, 0x76, 0x4a, 0x32, 0xcf, 0xa1, 0x95,
	0x37, 0xdc, 0x90, 0xbf, 0x3b, 0x50, 0x15, 0xd7, 0x9d, 0x96, 0x0f, 0x54, 0x5c, 0x77, 0x8f, 0x73,
	0x66, 0x27, 0x04, 0x21, 0xc3, 0x13, 0x1f, 0xf3, 0x3d, 0xc9, 0x2e, 0xe7, 0x42, 0xbe, 0x84, 0xcd,
	0x43, 0x80, 0xe5, 0xc4, 0x1b, 0x76, 0x95, 0x59, 0xca, 0x19, 0x76, 0xf8, 0xfe, 0x45, 0xb8, 0x9a,
	0xa5, 0x29, 0x6e, 0xfe, 0x58, 0x81, 0xf2, 0x9e, 0x35, 0x7a, 0xcf, 0xb6, 0x27, 0x49, 0x09, 0x0b,
	0x73, 0x4e, 0x58, 0xa0, 0x04, 0x9e, 0x4f, 0x09, 0x65, 0xb1, 0x73, 0x2c, 0xf9, 0xc4, 0x11, 0x3e,
	0xa3, 0xae, 0x7c, 0xe2, 0x1a, 0xd9, 0x13, 0x27, 0x31, 0x61, 0x75, 0xe9, 0x1c, 0x7b, 0xc9, 0xf3,
	0x9c, 0x59, 0x13, 0x4c, 0x56, 0x42, 0x8e, 0x79, 0x1c, 0x49, 0x2d, 0xe7, 0x2b, 0xa1, 0x44, 0xb3,
	0x4a, 0x28, 0xbf, 0xd0, 0x67, 0xb0, 0xe1, 0x85, 0x85, 0x97, 0x42, 0xca, 0xb8, 0xd9, 0xbb, 0x9d,
	0x4e, 0x5b, 0x79, 0x48, 0xfa, 0xb7, 0x45, 0x1e, 0x5c, 0xbe, 0xb9, 0xb3, 0xfa, 0xc2, 0xd8, 0xab,
	0x0b, 0x5d, 0xc9, 0xad, 0xfa, 0x3b, 0xe5, 0x56, 0x17, 0xaa, 0x01, 0x75, 0x49, 0xd4, 0x69, 0x14,
	0x95, 0x96, 0xaf, 0x49, 0x76, 0x42, 0x41, 0x9b, 0x50, 0x0d, 0x09, 0x9b, 0x47, 0x1d, 0x90, 0x4f,
	0x57, 0xf2, 0x21, 0x6e, 0x17, 0xc7, 0x7c, 0xf6, 0xc8, 0xf3, 0x45, 0x3d, 0x6d, 0xe6, 0x6f, 0x77,
	0x89, 0x8b, 0xc7, 0x9f, 0x15, 0x54, 0xde, 0x69, 0x15, 0x1f, 0xff, 0x62, 0x0e, 0xd8, 0x2b, 0xec,
	0x95, 0x1a, 0xb0, 0x7e, 0x7d, 0x0d, 0x30, 0xbf, 0xd1, 0xa0, 0x91, 0xe5, 0xda, 0xfb, 0x16, 0xfa,
	0x7b, 0x50, 0x76, 0xe6, 0xa1, 0x7a, 0xe1, 0x9a, 0x59, 0x0a, 0x1f, 0x59, 0x8a, 0x2a, 0xac, 0x42,
	0x1d, 0xe4, 0x22, 0x24, 0x0e, 0x2f, 0x14, 0x53, 0x85, 0x99, 0x3f, 0xe9, 0xb0, 0x66, 0xd3, 0x98,
	0x7b, 0xc1, 0xe9, 0x8d, 0x7a, 0x2e, 0x14, 0x7b, 0xfd, 0xfa, 0x62, 0xff, 0xbe, 0x85, 0x05, 0xfd,
	0x1f, 0xea, 0x11, 0x17, 0x5d, 0xeb, 0xe9, 0x42, 0x0a, 0xbc, 0xbd, 0x54, 0x9b, 0xf2, 0x6d, 0xac,
	0xcc, 0x59, 0x73, 0xa4, 0xbe, 0xd1, 0x7d, 0x68, 0xf2, 0x5c, 0xdf, 0x9c, 0xef, 0x4f, 0xf3, 0x86,
	0x77, 0xcc, 0x82, 0xbf, 0x43, 0x19, 0x87, 0x9e, 0x54, 0x7e, 0xa5, 0xdf, 0x54, 0xa1, 0x10, 0x39,
	0x6f, 0x0b, 0x3c, 0x4b, 0xee, 0xfa, 0x6a, 0x72, 0x77, 0xff, 0x09, 0xb5, 0x64, 0x41, 0x54, 0x87,
	0xca, 0x90, 0xbe, 0x0c, 0x8c, 0x12, 0xaa, 0x81, 0x7e, 0x1c, 0x1a, 0x1a, 0x6a, 0xc2, 0xda, 0x71,
	0x70, 0x16, 0x08, 0x50, 0xef, 0xee, 0xc2, 0xba, 0x6a, 0x22, 0x97, 0x7c, 0xd1, 0x42, 0x1b, 0x25,
	0x31, 0x3a, 0xc0, 0xfe, 0x89, 0xa1, 0xa1, 0x06, 0x54, 0x65, 0x2f, 0x6e, 0xe8, 0xdd, 0x7f, 0x41,
	0x33, 0xf7, 0x8f, 0x08, 0xb5, 0x01, 0x6c, 0x1a, 0x07, 0xae, 0x4d, 0xa7, 0x9e, 0x98, 0x03, 0x50,
	0x1b, 0x59, 0x07, 0x38, 0x9a, 0x19, 0x5a, 0xf7, 0x03, 0xa8, 0xa7, 0xbd, 0xb2, 0x5c, 0x6b, 0x32,
	0xb1, 0x92, 0x55, 0x1f, 0xb3, 0xd0, 0x49, 0x56, 0x1d, 0xc6, 0xd3, 0x29, 0x35, 0x74, 0xb4, 0x01,
	0xcd, 0x71, 0xc8, 0xbc, 0xe0, 0x74, 0xe0, 0xd3, 0xd8, 0x35, 0xca, 0xdd, 0xcf, 0xa1, 0x96, 0x34,
	0x48, 0xc2, 0xf4, 0x2c, 0x26, 0x6c, 0x31, 0xe6, 0xc2, 0x6e, 0x94, 0x50, 0x0b, 0xea, 0x8f, 0x28,
	0x9b, 0x0f, 0x31, 0xc7, 0x86, 0x26, 0xbe, 0x3e, 0x1d, 0x3f, 0x7d, 0xd2, 0xa7, 0xee, 0xc2, 0xd0,
	0xc5, 0xf6, 0x07, 0xb2, 0x99, 0x33, 0xca, 0x62, 0x3c, 0x90, 0xbd, 0x9a, 0x51, 0x41, 0xeb, 0xa2,
	0x59, 0xe3, 0x33, 0x99, 0xc0, 0x46, 0xb5, 0xbb, 0x05, 0xf5, 0xb4, 0x41, 0x92, 0x27, 0x88, 0x7d,
	0x62, 0x93, 0x53, 0x72, 0x11, 0x1a, 0xa5, 0xee, 0x31, 0x94, 0x07, 0x47, 0x96, 0x3c, 0xf2, 0x91,
	0xb5, 0xff, 0xcc, 0x28, 0xa9, 0xe1, 0xe1, 0x44, 0x05, 0xe2, 0xc8, 0x3a, 0xdc, 0x37, 0x74, 0x35,
	0x7c, 0x3c, 0x31, 0xca, 0xe9, 0x70, 0xdf, 0xa8, 0xa8, 0xe1, 0x28, 0x30, 0xaa, 0xc2, 0xb3, 0xc1,
	0x91, 0x75, 0x24, 0x4a, 0x82, 0x51, 0xeb, 0xde, 0x87, 0x8d, 0x15, 0x09, 0x89, 0x48, 0x0c, 0x68,
	0xb8, 0x48, 0x76, 0x18, 0x87, 0xbe, 0xc7, 0x0d, 0xad, 0xbf, 0xf9, 0xfa, 0x97, 0xed, 0xd2, 0xab,
	0xcb, 0x6d, 0xed, 0xf5, 0xe5, 0xb6, 0xf6, 0xf3, 0xe5, 0xb6, 0xf6, 0xfd, 0xaf, 0xdb, 0xa5, 0xdf,
	0x03, 0x00, 0x00, 0xff, 0xff, 0xc5, 0xfa, 0xd3, 0x50, 0x53, 0x0f, 0x00, 0x00,
}

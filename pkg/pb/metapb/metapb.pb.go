// Code generated by protoc-gen-gogo.
// source: metapb.proto
// DO NOT EDIT!

/*
	Package metapb is a generated protocol buffer package.

	It is generated from these files:
		metapb.proto

	It has these top-level messages:
		Proxy
		Cluster
		HeathCheck
		CircuitBreaker
		Server
		Bind
		PairValue
		IPAccessControl
		HTTPResult
		Parameter
		ValidationRule
		Validation
		DispatchNode
		API
		Condition
		Routing
*/
package metapb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Status is the components status
type Status int32

const (
	Down Status = 0
	Up   Status = 1
)

var Status_name = map[int32]string{
	0: "Down",
	1: "Up",
}
var Status_value = map[string]int32{
	"Down": 0,
	"Up":   1,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

// CircuitStatus is the circuit breaker status
type CircuitStatus int32

const (
	Open  CircuitStatus = 0
	Half  CircuitStatus = 1
	Close CircuitStatus = 2
)

var CircuitStatus_name = map[int32]string{
	0: "Open",
	1: "Half",
	2: "Close",
}
var CircuitStatus_value = map[string]int32{
	"Open":  0,
	"Half":  1,
	"Close": 2,
}

func (x CircuitStatus) Enum() *CircuitStatus {
	p := new(CircuitStatus)
	*p = x
	return p
}
func (x CircuitStatus) String() string {
	return proto.EnumName(CircuitStatus_name, int32(x))
}
func (x *CircuitStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CircuitStatus_value, data, "CircuitStatus")
	if err != nil {
		return err
	}
	*x = CircuitStatus(value)
	return nil
}
func (CircuitStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

// LoadBalance the load balance enum
type LoadBalance int32

const (
	RoundRobin LoadBalance = 0
	IPHash     LoadBalance = 1
)

var LoadBalance_name = map[int32]string{
	0: "RoundRobin",
	1: "IPHash",
}
var LoadBalance_value = map[string]int32{
	"RoundRobin": 0,
	"IPHash":     1,
}

func (x LoadBalance) Enum() *LoadBalance {
	p := new(LoadBalance)
	*p = x
	return p
}
func (x LoadBalance) String() string {
	return proto.EnumName(LoadBalance_name, int32(x))
}
func (x *LoadBalance) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LoadBalance_value, data, "LoadBalance")
	if err != nil {
		return err
	}
	*x = LoadBalance(value)
	return nil
}
func (LoadBalance) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

// Protocol is the protocol of the backend api
type Protocol int32

const (
	HTTP        Protocol = 0
	Grpc        Protocol = 1
	Dubbo       Protocol = 2
	SpringCloud Protocol = 3
)

var Protocol_name = map[int32]string{
	0: "HTTP",
	1: "Grpc",
	2: "Dubbo",
	3: "SpringCloud",
}
var Protocol_value = map[string]int32{
	"HTTP":        0,
	"Grpc":        1,
	"Dubbo":       2,
	"SpringCloud": 3,
}

func (x Protocol) Enum() *Protocol {
	p := new(Protocol)
	*p = x
	return p
}
func (x Protocol) String() string {
	return proto.EnumName(Protocol_name, int32(x))
}
func (x *Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Protocol_value, data, "Protocol")
	if err != nil {
		return err
	}
	*x = Protocol(value)
	return nil
}
func (Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

type Source int32

const (
	QueryString Source = 0
	FormData    Source = 1
	JSONBody    Source = 2
	Header      Source = 3
	Cookie      Source = 4
)

var Source_name = map[int32]string{
	0: "QueryString",
	1: "FormData",
	2: "JSONBody",
	3: "Header",
	4: "Cookie",
}
var Source_value = map[string]int32{
	"QueryString": 0,
	"FormData":    1,
	"JSONBody":    2,
	"Header":      3,
	"Cookie":      4,
}

func (x Source) Enum() *Source {
	p := new(Source)
	*p = x
	return p
}
func (x Source) String() string {
	return proto.EnumName(Source_name, int32(x))
}
func (x *Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Source_value, data, "Source")
	if err != nil {
		return err
	}
	*x = Source(value)
	return nil
}
func (Source) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

type RuleType int32

const (
	RuleRegexp RuleType = 0
)

var RuleType_name = map[int32]string{
	0: "RuleRegexp",
}
var RuleType_value = map[string]int32{
	"RuleRegexp": 0,
}

func (x RuleType) Enum() *RuleType {
	p := new(RuleType)
	*p = x
	return p
}
func (x RuleType) String() string {
	return proto.EnumName(RuleType_name, int32(x))
}
func (x *RuleType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RuleType_value, data, "RuleType")
	if err != nil {
		return err
	}
	*x = RuleType(value)
	return nil
}
func (RuleType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{5} }

type CMP int32

const (
	CMPEQ    CMP = 0
	CMPLT    CMP = 1
	CMPLE    CMP = 2
	CMPGT    CMP = 3
	CMPGE    CMP = 4
	CMPIn    CMP = 5
	CMPMatch CMP = 6
)

var CMP_name = map[int32]string{
	0: "CMPEQ",
	1: "CMPLT",
	2: "CMPLE",
	3: "CMPGT",
	4: "CMPGE",
	5: "CMPIn",
	6: "CMPMatch",
}
var CMP_value = map[string]int32{
	"CMPEQ":    0,
	"CMPLT":    1,
	"CMPLE":    2,
	"CMPGT":    3,
	"CMPGE":    4,
	"CMPIn":    5,
	"CMPMatch": 6,
}

func (x CMP) Enum() *CMP {
	p := new(CMP)
	*p = x
	return p
}
func (x CMP) String() string {
	return proto.EnumName(CMP_name, int32(x))
}
func (x *CMP) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CMP_value, data, "CMP")
	if err != nil {
		return err
	}
	*x = CMP(value)
	return nil
}
func (CMP) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{6} }

type RoutingStrategy int32

const (
	Copy  RoutingStrategy = 0
	Split RoutingStrategy = 1
)

var RoutingStrategy_name = map[int32]string{
	0: "Copy",
	1: "Split",
}
var RoutingStrategy_value = map[string]int32{
	"Copy":  0,
	"Split": 1,
}

func (x RoutingStrategy) Enum() *RoutingStrategy {
	p := new(RoutingStrategy)
	*p = x
	return p
}
func (x RoutingStrategy) String() string {
	return proto.EnumName(RoutingStrategy_name, int32(x))
}
func (x *RoutingStrategy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RoutingStrategy_value, data, "RoutingStrategy")
	if err != nil {
		return err
	}
	*x = RoutingStrategy(value)
	return nil
}
func (RoutingStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{7} }

// Proxy is a meta data of the gateway proxy
type Proxy struct {
	Addr             string `protobuf:"bytes,1,opt,name=addr" json:"addr"`
	AddrRPC          string `protobuf:"bytes,2,opt,name=addrRPC" json:"addrRPC"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Proxy) Reset()                    { *m = Proxy{} }
func (m *Proxy) String() string            { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()               {}
func (*Proxy) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

func (m *Proxy) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Proxy) GetAddrRPC() string {
	if m != nil {
		return m.AddrRPC
	}
	return ""
}

// Cluster is a set of server has same interface
type Cluster struct {
	ID               uint64      `protobuf:"varint,1,opt,name=id" json:"id"`
	Name             string      `protobuf:"bytes,2,opt,name=name" json:"name"`
	LoadBalance      LoadBalance `protobuf:"varint,3,opt,name=loadBalance,enum=metapb.LoadBalance" json:"loadBalance"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

func (m *Cluster) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetLoadBalance() LoadBalance {
	if m != nil {
		return m.LoadBalance
	}
	return RoundRobin
}

// HeathCheck is the heath check
type HeathCheck struct {
	Path             string `protobuf:"bytes,1,opt,name=path" json:"path"`
	Body             string `protobuf:"bytes,2,opt,name=body" json:"body"`
	CheckInterval    int64  `protobuf:"varint,3,opt,name=checkInterval" json:"checkInterval"`
	Timeout          int64  `protobuf:"varint,4,opt,name=timeout" json:"timeout"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *HeathCheck) Reset()                    { *m = HeathCheck{} }
func (m *HeathCheck) String() string            { return proto.CompactTextString(m) }
func (*HeathCheck) ProtoMessage()               {}
func (*HeathCheck) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

func (m *HeathCheck) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HeathCheck) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *HeathCheck) GetCheckInterval() int64 {
	if m != nil {
		return m.CheckInterval
	}
	return 0
}

func (m *HeathCheck) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// CircuitBreaker circuit breaker
type CircuitBreaker struct {
	CloseTimeout       int64  `protobuf:"varint,1,opt,name=closeTimeout" json:"closeTimeout"`
	HalfTrafficRate    int32  `protobuf:"varint,2,opt,name=halfTrafficRate" json:"halfTrafficRate"`
	RateCheckPeriod    int64  `protobuf:"varint,3,opt,name=rateCheckPeriod" json:"rateCheckPeriod"`
	FailureRateToClose int32  `protobuf:"varint,4,opt,name=failureRateToClose" json:"failureRateToClose"`
	SucceedRateToOpen  int32  `protobuf:"varint,5,opt,name=succeedRateToOpen" json:"succeedRateToOpen"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *CircuitBreaker) Reset()                    { *m = CircuitBreaker{} }
func (m *CircuitBreaker) String() string            { return proto.CompactTextString(m) }
func (*CircuitBreaker) ProtoMessage()               {}
func (*CircuitBreaker) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

func (m *CircuitBreaker) GetCloseTimeout() int64 {
	if m != nil {
		return m.CloseTimeout
	}
	return 0
}

func (m *CircuitBreaker) GetHalfTrafficRate() int32 {
	if m != nil {
		return m.HalfTrafficRate
	}
	return 0
}

func (m *CircuitBreaker) GetRateCheckPeriod() int64 {
	if m != nil {
		return m.RateCheckPeriod
	}
	return 0
}

func (m *CircuitBreaker) GetFailureRateToClose() int32 {
	if m != nil {
		return m.FailureRateToClose
	}
	return 0
}

func (m *CircuitBreaker) GetSucceedRateToOpen() int32 {
	if m != nil {
		return m.SucceedRateToOpen
	}
	return 0
}

// Server is a backend server that provide api
type Server struct {
	ID               uint64          `protobuf:"varint,1,opt,name=id" json:"id"`
	Addr             string          `protobuf:"bytes,2,opt,name=addr" json:"addr"`
	Protocol         Protocol        `protobuf:"varint,3,opt,name=protocol,enum=metapb.Protocol" json:"protocol"`
	MaxQPS           int64           `protobuf:"varint,4,opt,name=maxQPS" json:"maxQPS"`
	HeathCheck       *HeathCheck     `protobuf:"bytes,5,opt,name=heathCheck" json:"heathCheck,omitempty"`
	CircuitBreaker   *CircuitBreaker `protobuf:"bytes,6,opt,name=circuitBreaker" json:"circuitBreaker,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

func (m *Server) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Server) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Server) GetProtocol() Protocol {
	if m != nil {
		return m.Protocol
	}
	return HTTP
}

func (m *Server) GetMaxQPS() int64 {
	if m != nil {
		return m.MaxQPS
	}
	return 0
}

func (m *Server) GetHeathCheck() *HeathCheck {
	if m != nil {
		return m.HeathCheck
	}
	return nil
}

func (m *Server) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

// Bind is a bind pair with cluster and server
type Bind struct {
	ClusterID        uint64 `protobuf:"varint,1,opt,name=clusterID" json:"clusterID"`
	ServerID         uint64 `protobuf:"varint,2,opt,name=serverID" json:"serverID"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Bind) Reset()                    { *m = Bind{} }
func (m *Bind) String() string            { return proto.CompactTextString(m) }
func (*Bind) ProtoMessage()               {}
func (*Bind) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{5} }

func (m *Bind) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Bind) GetServerID() uint64 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

// Pair is pair value
type PairValue struct {
	Name             string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value            string `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PairValue) Reset()                    { *m = PairValue{} }
func (m *PairValue) String() string            { return proto.CompactTextString(m) }
func (*PairValue) ProtoMessage()               {}
func (*PairValue) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{6} }

func (m *PairValue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PairValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IPAccessControl is for ip access control
type IPAccessControl struct {
	Whitelist        []string `protobuf:"bytes,1,rep,name=whitelist" json:"whitelist,omitempty"`
	Blacklist        []string `protobuf:"bytes,2,rep,name=blacklist" json:"blacklist,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *IPAccessControl) Reset()                    { *m = IPAccessControl{} }
func (m *IPAccessControl) String() string            { return proto.CompactTextString(m) }
func (*IPAccessControl) ProtoMessage()               {}
func (*IPAccessControl) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{7} }

func (m *IPAccessControl) GetWhitelist() []string {
	if m != nil {
		return m.Whitelist
	}
	return nil
}

func (m *IPAccessControl) GetBlacklist() []string {
	if m != nil {
		return m.Blacklist
	}
	return nil
}

// HTTPResult is a http result
type HTTPResult struct {
	Body             []byte       `protobuf:"bytes,1,opt,name=body" json:"body,omitempty"`
	Headers          []*PairValue `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	Cookies          []*PairValue `protobuf:"bytes,3,rep,name=cookies" json:"cookies,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *HTTPResult) Reset()                    { *m = HTTPResult{} }
func (m *HTTPResult) String() string            { return proto.CompactTextString(m) }
func (*HTTPResult) ProtoMessage()               {}
func (*HTTPResult) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{8} }

func (m *HTTPResult) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *HTTPResult) GetHeaders() []*PairValue {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HTTPResult) GetCookies() []*PairValue {
	if m != nil {
		return m.Cookies
	}
	return nil
}

// Parameter is a parameter from a http request
type Parameter struct {
	Name             string `protobuf:"bytes,1,opt,name=name" json:"name"`
	Source           Source `protobuf:"varint,2,opt,name=source,enum=metapb.Source" json:"source"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (m *Parameter) String() string            { return proto.CompactTextString(m) }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{9} }

func (m *Parameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Parameter) GetSource() Source {
	if m != nil {
		return m.Source
	}
	return QueryString
}

// ValidationRule is a validation rule
type ValidationRule struct {
	RuleType         RuleType `protobuf:"varint,1,opt,name=ruleType,enum=metapb.RuleType" json:"ruleType"`
	Expression       string   `protobuf:"bytes,2,opt,name=expression" json:"expression"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ValidationRule) Reset()                    { *m = ValidationRule{} }
func (m *ValidationRule) String() string            { return proto.CompactTextString(m) }
func (*ValidationRule) ProtoMessage()               {}
func (*ValidationRule) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{10} }

func (m *ValidationRule) GetRuleType() RuleType {
	if m != nil {
		return m.RuleType
	}
	return RuleRegexp
}

func (m *ValidationRule) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

// Validation is a validation
type Validation struct {
	Parameter        Parameter        `protobuf:"bytes,1,opt,name=parameter" json:"parameter"`
	Required         bool             `protobuf:"varint,2,opt,name=required" json:"required"`
	Rules            []ValidationRule `protobuf:"bytes,3,rep,name=rules" json:"rules"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Validation) Reset()                    { *m = Validation{} }
func (m *Validation) String() string            { return proto.CompactTextString(m) }
func (*Validation) ProtoMessage()               {}
func (*Validation) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{11} }

func (m *Validation) GetParameter() Parameter {
	if m != nil {
		return m.Parameter
	}
	return Parameter{}
}

func (m *Validation) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *Validation) GetRules() []ValidationRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// DispatchNode is the request forward to
type DispatchNode struct {
	ClusterID        uint64        `protobuf:"varint,1,opt,name=clusterID" json:"clusterID"`
	URLRewrite       uint64        `protobuf:"varint,2,opt,name=urlRewrite" json:"urlRewrite"`
	AttrName         uint64        `protobuf:"varint,3,opt,name=attrName" json:"attrName"`
	Validations      []*Validation `protobuf:"bytes,4,rep,name=validations" json:"validations,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *DispatchNode) Reset()                    { *m = DispatchNode{} }
func (m *DispatchNode) String() string            { return proto.CompactTextString(m) }
func (*DispatchNode) ProtoMessage()               {}
func (*DispatchNode) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{12} }

func (m *DispatchNode) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *DispatchNode) GetURLRewrite() uint64 {
	if m != nil {
		return m.URLRewrite
	}
	return 0
}

func (m *DispatchNode) GetAttrName() uint64 {
	if m != nil {
		return m.AttrName
	}
	return 0
}

func (m *DispatchNode) GetValidations() []*Validation {
	if m != nil {
		return m.Validations
	}
	return nil
}

// API is the api for dispatcher
type API struct {
	ID               uint64           `protobuf:"varint,1,opt,name=id" json:"id"`
	Name             string           `protobuf:"bytes,2,opt,name=name" json:"name"`
	URLPattern       string           `protobuf:"bytes,3,opt,name=urlPattern" json:"urlPattern"`
	Method           string           `protobuf:"bytes,4,opt,name=method" json:"method"`
	Domain           string           `protobuf:"bytes,5,opt,name=domain" json:"domain"`
	Status           Status           `protobuf:"varint,6,opt,name=status,enum=metapb.Status" json:"status"`
	IPAccessControl  *IPAccessControl `protobuf:"bytes,7,opt,name=ipAccessControl" json:"ipAccessControl,omitempty"`
	DefaultValue     *HTTPResult      `protobuf:"bytes,8,opt,name=defaultValue" json:"defaultValue,omitempty"`
	Nodes            []*DispatchNode  `protobuf:"bytes,9,rep,name=nodes" json:"nodes,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *API) Reset()                    { *m = API{} }
func (m *API) String() string            { return proto.CompactTextString(m) }
func (*API) ProtoMessage()               {}
func (*API) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{13} }

func (m *API) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *API) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *API) GetURLPattern() string {
	if m != nil {
		return m.URLPattern
	}
	return ""
}

func (m *API) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *API) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *API) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func (m *API) GetIPAccessControl() *IPAccessControl {
	if m != nil {
		return m.IPAccessControl
	}
	return nil
}

func (m *API) GetDefaultValue() *HTTPResult {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *API) GetNodes() []*DispatchNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// Condition is a condition for routing
type Condition struct {
	Parameter        Parameter `protobuf:"bytes,1,opt,name=parameter" json:"parameter"`
	Cmp              CMP       `protobuf:"varint,2,opt,name=cmp,enum=metapb.CMP" json:"cmp"`
	Expect           string    `protobuf:"bytes,3,opt,name=expect" json:"expect"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Condition) Reset()                    { *m = Condition{} }
func (m *Condition) String() string            { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()               {}
func (*Condition) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{14} }

func (m *Condition) GetParameter() Parameter {
	if m != nil {
		return m.Parameter
	}
	return Parameter{}
}

func (m *Condition) GetCmp() CMP {
	if m != nil {
		return m.Cmp
	}
	return CMPEQ
}

func (m *Condition) GetExpect() string {
	if m != nil {
		return m.Expect
	}
	return ""
}

// Routing is a routing
type Routing struct {
	ID               uint64          `protobuf:"varint,1,opt,name=id" json:"id"`
	ClusterID        int64           `protobuf:"varint,2,opt,name=clusterID" json:"clusterID"`
	Conditions       []Condition     `protobuf:"bytes,3,rep,name=conditions" json:"conditions"`
	Strategy         RoutingStrategy `protobuf:"varint,4,opt,name=strategy,enum=metapb.RoutingStrategy" json:"strategy"`
	TrafficRate      int32           `protobuf:"varint,5,opt,name=trafficRate" json:"trafficRate"`
	Status           Status          `protobuf:"varint,6,opt,name=status,enum=metapb.Status" json:"status"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Routing) Reset()                    { *m = Routing{} }
func (m *Routing) String() string            { return proto.CompactTextString(m) }
func (*Routing) ProtoMessage()               {}
func (*Routing) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{15} }

func (m *Routing) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Routing) GetClusterID() int64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *Routing) GetConditions() []Condition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Routing) GetStrategy() RoutingStrategy {
	if m != nil {
		return m.Strategy
	}
	return Copy
}

func (m *Routing) GetTrafficRate() int32 {
	if m != nil {
		return m.TrafficRate
	}
	return 0
}

func (m *Routing) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Down
}

func init() {
	proto.RegisterType((*Proxy)(nil), "metapb.Proxy")
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*HeathCheck)(nil), "metapb.HeathCheck")
	proto.RegisterType((*CircuitBreaker)(nil), "metapb.CircuitBreaker")
	proto.RegisterType((*Server)(nil), "metapb.Server")
	proto.RegisterType((*Bind)(nil), "metapb.Bind")
	proto.RegisterType((*PairValue)(nil), "metapb.PairValue")
	proto.RegisterType((*IPAccessControl)(nil), "metapb.IPAccessControl")
	proto.RegisterType((*HTTPResult)(nil), "metapb.HTTPResult")
	proto.RegisterType((*Parameter)(nil), "metapb.Parameter")
	proto.RegisterType((*ValidationRule)(nil), "metapb.ValidationRule")
	proto.RegisterType((*Validation)(nil), "metapb.Validation")
	proto.RegisterType((*DispatchNode)(nil), "metapb.DispatchNode")
	proto.RegisterType((*API)(nil), "metapb.API")
	proto.RegisterType((*Condition)(nil), "metapb.Condition")
	proto.RegisterType((*Routing)(nil), "metapb.Routing")
	proto.RegisterEnum("metapb.Status", Status_name, Status_value)
	proto.RegisterEnum("metapb.CircuitStatus", CircuitStatus_name, CircuitStatus_value)
	proto.RegisterEnum("metapb.LoadBalance", LoadBalance_name, LoadBalance_value)
	proto.RegisterEnum("metapb.Protocol", Protocol_name, Protocol_value)
	proto.RegisterEnum("metapb.Source", Source_name, Source_value)
	proto.RegisterEnum("metapb.RuleType", RuleType_name, RuleType_value)
	proto.RegisterEnum("metapb.CMP", CMP_name, CMP_value)
	proto.RegisterEnum("metapb.RoutingStrategy", RoutingStrategy_name, RoutingStrategy_value)
}
func (m *Proxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proxy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
	i += copy(dAtA[i:], m.Addr)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.AddrRPC)))
	i += copy(dAtA[i:], m.AddrRPC)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.LoadBalance))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeathCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeathCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Body)))
	i += copy(dAtA[i:], m.Body)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.CheckInterval))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Timeout))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CircuitBreaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitBreaker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.CloseTimeout))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.HalfTrafficRate))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RateCheckPeriod))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.FailureRateToClose))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.SucceedRateToOpen))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Server) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
	i += copy(dAtA[i:], m.Addr)
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Protocol))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.MaxQPS))
	if m.HeathCheck != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.HeathCheck.Size()))
		n1, err := m.HeathCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CircuitBreaker != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CircuitBreaker.Size()))
		n2, err := m.CircuitBreaker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ServerID))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PairValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PairValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IPAccessControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPAccessControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cookies) > 0 {
		for _, msg := range m.Cookies {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Source))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidationRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidationRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.RuleType))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expression)))
	i += copy(dAtA[i:], m.Expression)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Validation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Parameter.Size()))
	n3, err := m.Parameter.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x10
	i++
	if m.Required {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DispatchNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.URLRewrite))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.AttrName))
	if len(m.Validations) > 0 {
		for _, msg := range m.Validations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *API) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *API) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.URLPattern)))
	i += copy(dAtA[i:], m.URLPattern)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Method)))
	i += copy(dAtA[i:], m.Method)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	if m.IPAccessControl != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.IPAccessControl.Size()))
		n4, err := m.IPAccessControl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DefaultValue.Size()))
		n5, err := m.DefaultValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Parameter.Size()))
	n6, err := m.Parameter.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Cmp))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(len(m.Expect)))
	i += copy(dAtA[i:], m.Expect)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Routing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Routing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Strategy))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.TrafficRate))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Status))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Metapb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Metapb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Proxy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.AddrRPC)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.LoadBalance))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeathCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Body)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.CheckInterval))
	n += 1 + sovMetapb(uint64(m.Timeout))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CircuitBreaker) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.CloseTimeout))
	n += 1 + sovMetapb(uint64(m.HalfTrafficRate))
	n += 1 + sovMetapb(uint64(m.RateCheckPeriod))
	n += 1 + sovMetapb(uint64(m.FailureRateToClose))
	n += 1 + sovMetapb(uint64(m.SucceedRateToOpen))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Server) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Addr)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Protocol))
	n += 1 + sovMetapb(uint64(m.MaxQPS))
	if m.HeathCheck != nil {
		l = m.HeathCheck.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bind) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ClusterID))
	n += 1 + sovMetapb(uint64(m.ServerID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PairValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPAccessControl) Size() (n int) {
	var l int
	_ = l
	if len(m.Whitelist) > 0 {
		for _, s := range m.Whitelist {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Blacklist) > 0 {
		for _, s := range m.Blacklist {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPResult) Size() (n int) {
	var l int
	_ = l
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Cookies) > 0 {
		for _, e := range m.Cookies {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Parameter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Source))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidationRule) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.RuleType))
	l = len(m.Expression)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Validation) Size() (n int) {
	var l int
	_ = l
	l = m.Parameter.Size()
	n += 1 + l + sovMetapb(uint64(l))
	n += 2
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DispatchNode) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ClusterID))
	n += 1 + sovMetapb(uint64(m.URLRewrite))
	n += 1 + sovMetapb(uint64(m.AttrName))
	if len(m.Validations) > 0 {
		for _, e := range m.Validations {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *API) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.URLPattern)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Method)
	n += 1 + l + sovMetapb(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Status))
	if m.IPAccessControl != nil {
		l = m.IPAccessControl.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	var l int
	_ = l
	l = m.Parameter.Size()
	n += 1 + l + sovMetapb(uint64(l))
	n += 1 + sovMetapb(uint64(m.Cmp))
	l = len(m.Expect)
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Routing) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMetapb(uint64(m.ID))
	n += 1 + sovMetapb(uint64(m.ClusterID))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	n += 1 + sovMetapb(uint64(m.Strategy))
	n += 1 + sovMetapb(uint64(m.TrafficRate))
	n += 1 + sovMetapb(uint64(m.Status))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Proxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrRPC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddrRPC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalance", wireType)
			}
			m.LoadBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadBalance |= (LoadBalance(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeathCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeathCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeathCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckInterval", wireType)
			}
			m.CheckInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitBreaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitBreaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitBreaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTimeout", wireType)
			}
			m.CloseTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTimeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalfTrafficRate", wireType)
			}
			m.HalfTrafficRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HalfTrafficRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateCheckPeriod", wireType)
			}
			m.RateCheckPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateCheckPeriod |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureRateToClose", wireType)
			}
			m.FailureRateToClose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureRateToClose |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceedRateToOpen", wireType)
			}
			m.SucceedRateToOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SucceedRateToOpen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQPS", wireType)
			}
			m.MaxQPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQPS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeathCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeathCheck == nil {
				m.HeathCheck = &HeathCheck{}
			}
			if err := m.HeathCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PairValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PairValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PairValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPAccessControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAccessControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAccessControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Whitelist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Whitelist = append(m.Whitelist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blacklist = append(m.Blacklist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &PairValue{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookies = append(m.Cookies, &PairValue{})
			if err := m.Cookies[len(m.Cookies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (Source(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidationRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidationRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidationRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleType", wireType)
			}
			m.RuleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleType |= (RuleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, ValidationRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLRewrite", wireType)
			}
			m.URLRewrite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URLRewrite |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrName", wireType)
			}
			m.AttrName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrName |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validations = append(m.Validations, &Validation{})
			if err := m.Validations[len(m.Validations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *API) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: API: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: API: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLPattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLPattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAccessControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPAccessControl == nil {
				m.IPAccessControl = &IPAccessControl{}
			}
			if err := m.IPAccessControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &HTTPResult{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &DispatchNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parameter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmp", wireType)
			}
			m.Cmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmp |= (CMP(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Routing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Routing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Routing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= (RoutingStrategy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficRate", wireType)
			}
			m.TrafficRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("metapb.proto", fileDescriptorMetapb) }

var fileDescriptorMetapb = []byte{
	// 1312 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x16, 0xa9, 0x0f, 0x4b, 0x23, 0x47, 0x66, 0xf6, 0x0d, 0xde, 0x08, 0x46, 0x61, 0x07, 0x6c,
	0x11, 0xb8, 0x6a, 0xe1, 0x02, 0x42, 0x8a, 0xa2, 0x1f, 0x28, 0x60, 0x49, 0x69, 0xac, 0xc2, 0x4a,
	0x18, 0x4a, 0xc9, 0xa1, 0xb7, 0x35, 0xb9, 0xb6, 0xb6, 0xa6, 0xb8, 0xec, 0x72, 0xe9, 0x58, 0x45,
	0x8f, 0xed, 0xad, 0xb7, 0x5e, 0xda, 0x53, 0xff, 0x49, 0xcf, 0x3e, 0xe6, 0x17, 0x18, 0xad, 0xfb,
	0x47, 0x8a, 0x5d, 0x2e, 0x29, 0x52, 0x4e, 0xfa, 0x79, 0xd2, 0xf2, 0x99, 0x67, 0x76, 0x67, 0x66,
	0x9f, 0x99, 0x15, 0x6c, 0x2e, 0x88, 0xc0, 0xd1, 0xf1, 0x7e, 0xc4, 0x99, 0x60, 0xa8, 0x91, 0x7e,
	0x6d, 0xdf, 0x39, 0x65, 0xa7, 0x4c, 0x41, 0xef, 0xc9, 0x55, 0x6a, 0xb5, 0x0f, 0xa0, 0xee, 0x70,
	0x76, 0xb1, 0x44, 0x5d, 0xa8, 0x61, 0xdf, 0xe7, 0x5d, 0xe3, 0x9e, 0xb1, 0xd7, 0x1a, 0xd4, 0x2e,
	0xaf, 0x76, 0x2b, 0xae, 0x42, 0xd0, 0x0e, 0x6c, 0xc8, 0x5f, 0xd7, 0x19, 0x76, 0xcd, 0x82, 0x31,
	0x03, 0xed, 0x6f, 0x60, 0x63, 0x18, 0x24, 0xb1, 0x20, 0x1c, 0x6d, 0x83, 0x49, 0x7d, 0xb5, 0x45,
	0x6d, 0x00, 0x92, 0x75, 0x7d, 0xb5, 0x6b, 0x8e, 0x47, 0xae, 0x49, 0x7d, 0x79, 0x40, 0x88, 0x17,
	0xa4, 0xb4, 0x87, 0x42, 0xd0, 0xc7, 0xd0, 0x0e, 0x18, 0xf6, 0x07, 0x38, 0xc0, 0xa1, 0x47, 0xba,
	0xd5, 0x7b, 0xc6, 0x5e, 0xa7, 0xff, 0xbf, 0x7d, 0x9d, 0xc5, 0xd1, 0xca, 0xa4, 0xbd, 0x8a, 0x6c,
	0xfb, 0x7b, 0x03, 0xe0, 0x90, 0x60, 0x31, 0x1f, 0xce, 0x89, 0x77, 0x26, 0x4f, 0x89, 0xb0, 0x98,
	0x97, 0xd3, 0x90, 0x88, 0xb4, 0x1c, 0x33, 0x7f, 0x59, 0x3e, 0x5f, 0x22, 0xa8, 0x07, 0xb7, 0x3c,
	0xe9, 0x3c, 0x0e, 0x05, 0xe1, 0xe7, 0x38, 0x50, 0x11, 0x54, 0x35, 0xa5, 0x6c, 0x92, 0xc5, 0x10,
	0x74, 0x41, 0x58, 0x22, 0xba, 0xb5, 0x02, 0x2b, 0x03, 0xed, 0x6f, 0x4d, 0xe8, 0x0c, 0x29, 0xf7,
	0x12, 0x2a, 0x06, 0x9c, 0xe0, 0x33, 0xc2, 0xd1, 0x1e, 0x6c, 0x7a, 0x01, 0x8b, 0xc9, 0x4c, 0xfb,
	0x19, 0x05, 0xbf, 0x92, 0x05, 0xed, 0xc3, 0xd6, 0x1c, 0x07, 0x27, 0x33, 0x8e, 0x4f, 0x4e, 0xa8,
	0xe7, 0x62, 0x91, 0x56, 0xab, 0xae, 0xc9, 0xeb, 0x46, 0xc9, 0xe7, 0x58, 0x10, 0x95, 0xb9, 0x43,
	0x38, 0x65, 0x7e, 0x29, 0xf4, 0x75, 0x23, 0x7a, 0x00, 0xe8, 0x04, 0xd3, 0x20, 0xe1, 0x44, 0xba,
	0xcf, 0xd8, 0x50, 0x1e, 0xae, 0xf2, 0xc8, 0x8e, 0x78, 0x85, 0x1d, 0xf5, 0xe1, 0x76, 0x9c, 0x78,
	0x1e, 0x21, 0x7e, 0x8a, 0x3e, 0x89, 0x48, 0xd8, 0xad, 0x17, 0x9c, 0x6e, 0x9a, 0x65, 0x19, 0x1a,
	0x53, 0xc2, 0xcf, 0xff, 0x5a, 0x13, 0x4a, 0x74, 0xe6, 0x0d, 0xd1, 0xf5, 0xa1, 0xa9, 0x04, 0xea,
	0xb1, 0x40, 0x0b, 0xc2, 0xca, 0x04, 0xe1, 0x68, 0x5c, 0xf3, 0x73, 0x1e, 0x7a, 0x03, 0x1a, 0x0b,
	0x7c, 0xf1, 0xd4, 0x99, 0x96, 0xae, 0x46, 0x63, 0xa8, 0x0f, 0x30, 0xcf, 0x75, 0xa2, 0xe2, 0x6f,
	0xf7, 0x51, 0xb6, 0xe7, 0x4a, 0x41, 0x6e, 0x81, 0x85, 0x3e, 0x85, 0x8e, 0x57, 0xba, 0xcc, 0x6e,
	0x43, 0xf9, 0xfd, 0x3f, 0xf3, 0x2b, 0x5f, 0xb5, 0xbb, 0xc6, 0xb6, 0x8f, 0xa0, 0x36, 0xa0, 0xa1,
	0x8f, 0x6c, 0x68, 0x79, 0x69, 0x8b, 0x8c, 0x47, 0xba, 0x14, 0x69, 0x70, 0x2b, 0x18, 0xdd, 0x83,
	0x66, 0xac, 0x2a, 0x36, 0x1e, 0xa9, 0x7a, 0x64, 0x94, 0x1c, 0xb5, 0x0f, 0xa0, 0xe5, 0x60, 0xca,
	0x9f, 0xe3, 0x20, 0x21, 0x79, 0x3b, 0x19, 0x37, 0xda, 0x69, 0x1b, 0xea, 0xe7, 0x92, 0x52, 0xaa,
	0x6a, 0x0a, 0xd9, 0x13, 0xd8, 0x1a, 0x3b, 0x07, 0x9e, 0x47, 0xe2, 0x78, 0xc8, 0x42, 0xc1, 0x55,
	0xd5, 0x5a, 0x2f, 0xe6, 0x54, 0x90, 0x80, 0xc6, 0x52, 0x9b, 0xd5, 0xbd, 0x96, 0xbb, 0x02, 0xa4,
	0xf5, 0x38, 0xc0, 0xde, 0x99, 0xb2, 0x9a, 0xa9, 0x35, 0x07, 0xec, 0xaf, 0x01, 0x0e, 0x67, 0x33,
	0xc7, 0x25, 0x71, 0x12, 0x08, 0x84, 0x74, 0x87, 0xc9, 0x90, 0x36, 0x75, 0x6f, 0xbd, 0x03, 0x1b,
	0x73, 0x82, 0x7d, 0xc2, 0x63, 0xe5, 0xdd, 0xee, 0xdf, 0xce, 0xaf, 0x31, 0x4b, 0xc5, 0xcd, 0x18,
	0x92, 0xec, 0x31, 0x76, 0x46, 0x49, 0xdc, 0xad, 0xbe, 0x96, 0xac, 0x19, 0xf6, 0x54, 0x56, 0x83,
	0xe3, 0x05, 0x91, 0x83, 0xe7, 0xf5, 0xd5, 0x78, 0x17, 0x1a, 0x31, 0x4b, 0xb8, 0x97, 0x96, 0xa3,
	0xd3, 0xef, 0x64, 0x5b, 0x4e, 0x15, 0x9a, 0x89, 0x24, 0xe5, 0xd8, 0x5f, 0x42, 0xe7, 0x39, 0x0e,
	0xa8, 0x8f, 0x05, 0x65, 0xa1, 0x9b, 0x04, 0x52, 0xfd, 0x4d, 0x9e, 0x04, 0x64, 0xb6, 0x8c, 0xd2,
	0xdd, 0x0b, 0x42, 0x74, 0x35, 0x9e, 0x5d, 0x54, 0xc6, 0x43, 0x6f, 0x01, 0x90, 0x8b, 0x88, 0x93,
	0x38, 0xa6, 0x2c, 0x2c, 0x5d, 0x43, 0x01, 0xb7, 0x7f, 0x32, 0x00, 0x56, 0x87, 0xa1, 0xf7, 0xa1,
	0x15, 0x65, 0xf9, 0xa8, 0x93, 0x4a, 0xe9, 0x6b, 0x43, 0x26, 0x9b, 0x9c, 0x29, 0x65, 0xc3, 0xc9,
	0x57, 0x09, 0xe5, 0xc4, 0x57, 0x27, 0x35, 0xf3, 0x68, 0x34, 0x8a, 0xfa, 0x50, 0x97, 0x91, 0x65,
	0x35, 0xcd, 0xb5, 0x5b, 0x4e, 0x34, 0xd3, 0x89, 0xa2, 0xda, 0xbf, 0x18, 0xb0, 0x39, 0xa2, 0x71,
	0x84, 0x85, 0x37, 0x7f, 0xcc, 0x7c, 0xf2, 0xb7, 0x14, 0xdc, 0x07, 0x48, 0x78, 0xe0, 0x92, 0x17,
	0x9c, 0xea, 0xc9, 0x55, 0x1b, 0x20, 0xdd, 0xf1, 0xf0, 0xcc, 0x3d, 0xd2, 0x16, 0xb7, 0xc0, 0x92,
	0xe1, 0x63, 0x21, 0xf8, 0x63, 0x79, 0x79, 0xd5, 0xa2, 0xea, 0x33, 0x14, 0x3d, 0x80, 0xf6, 0x79,
	0x1e, 0x69, 0xdc, 0xad, 0xa9, 0x24, 0xd0, 0x2b, 0x92, 0x28, 0xd2, 0xec, 0x9f, 0xab, 0x50, 0x3d,
	0x70, 0xc6, 0xff, 0xf2, 0x45, 0x4a, 0x33, 0x71, 0xb0, 0x10, 0x84, 0x87, 0x2a, 0xae, 0x56, 0x29,
	0x13, 0x6d, 0x71, 0x0b, 0x2c, 0x35, 0x7d, 0x88, 0x98, 0x33, 0x5f, 0x4d, 0x9f, 0x56, 0x3e, 0x7d,
	0x14, 0x26, 0xad, 0x3e, 0x5b, 0x60, 0x9a, 0x4e, 0xce, 0xdc, 0x9a, 0x62, 0x4a, 0xa4, 0x02, 0x8b,
	0x24, 0x56, 0xf3, 0xa5, 0x28, 0x52, 0x85, 0xe6, 0x22, 0x55, 0x5f, 0xe8, 0x0b, 0xd8, 0xa2, 0x51,
	0xa9, 0x89, 0xbb, 0x1b, 0x4a, 0x2f, 0x77, 0x33, 0xb7, 0xb5, 0x1e, 0x1f, 0xdc, 0xbd, 0xbc, 0xda,
	0x35, 0xae, 0xaf, 0x76, 0xd7, 0x9b, 0xdf, 0x5d, 0xdf, 0x08, 0x7d, 0x02, 0x9b, 0x3e, 0x39, 0xc1,
	0x49, 0x20, 0x54, 0xbb, 0x75, 0x9b, 0x6b, 0x73, 0x32, 0xef, 0x76, 0x15, 0x93, 0xe1, 0x96, 0xd8,
	0xa8, 0x07, 0xf5, 0x90, 0xf9, 0x24, 0xee, 0xb6, 0xd4, 0x2d, 0xdd, 0xc9, 0xdc, 0x8a, 0x52, 0x72,
	0x53, 0x8a, 0xfd, 0x9d, 0x01, 0xad, 0x21, 0x0b, 0x7d, 0xfa, 0x5f, 0xd4, 0xff, 0x26, 0x54, 0xbd,
	0x45, 0xa4, 0x5b, 0xbb, 0x9d, 0x4f, 0xe5, 0x89, 0xa3, 0xa9, 0xd2, 0x2a, 0x6b, 0x4f, 0x2e, 0x22,
	0xe2, 0x09, 0x7d, 0x93, 0xba, 0x9a, 0x29, 0x66, 0xff, 0x60, 0xc2, 0x86, 0xcb, 0x12, 0x41, 0xc3,
	0xd3, 0x3f, 0x55, 0x4b, 0xa9, 0x03, 0xcc, 0xc2, 0x03, 0x53, 0xe8, 0x80, 0x0f, 0x00, 0xbc, 0x2c,
	0xa5, 0x1b, 0x33, 0x2c, 0x4f, 0x36, 0x9b, 0x05, 0x2b, 0x2a, 0xfa, 0x10, 0x9a, 0xb1, 0x90, 0xcf,
	0xf5, 0xe9, 0x52, 0xc9, 0xa7, 0xb3, 0xba, 0x4b, 0x1d, 0xdb, 0x54, 0x9b, 0xf3, 0x57, 0x41, 0x7f,
	0xa3, 0xfb, 0xd0, 0x16, 0x85, 0x3f, 0x0c, 0xc5, 0x87, 0xb9, 0x68, 0xf8, 0x67, 0x1a, 0xeb, 0x6d,
	0x43, 0x23, 0xc5, 0x51, 0x13, 0x6a, 0x23, 0xf6, 0x22, 0xb4, 0x2a, 0xa8, 0x01, 0xe6, 0xb3, 0xc8,
	0x32, 0x7a, 0xfb, 0x70, 0x4b, 0xbf, 0x7b, 0x2b, 0x8a, 0x7c, 0xf5, 0xad, 0x8a, 0x5c, 0x1d, 0xe2,
	0xe0, 0xc4, 0x32, 0x50, 0x0b, 0xea, 0xea, 0xef, 0x83, 0x65, 0xf6, 0xde, 0x86, 0x76, 0xe1, 0x4f,
	0x1c, 0xea, 0x00, 0xb8, 0x2c, 0x09, 0x7d, 0x97, 0x1d, 0x53, 0xe9, 0x03, 0xd0, 0x18, 0x3b, 0x87,
	0x38, 0x9e, 0x5b, 0x46, 0xef, 0x23, 0x68, 0x66, 0xcf, 0xbb, 0xda, 0x6b, 0x36, 0x73, 0xd2, 0x5d,
	0x1f, 0xf1, 0xc8, 0x4b, 0x77, 0x1d, 0x25, 0xc7, 0xc7, 0xcc, 0x32, 0xd1, 0x16, 0xb4, 0xa7, 0x11,
	0xa7, 0xe1, 0xe9, 0x30, 0x60, 0x89, 0x6f, 0x55, 0x7b, 0x13, 0x68, 0xa4, 0x33, 0x5d, 0x9a, 0x9e,
	0x26, 0x84, 0x2f, 0xa7, 0x42, 0xda, 0xad, 0x0a, 0xda, 0x84, 0xe6, 0x67, 0x8c, 0x2f, 0x46, 0x58,
	0x60, 0xcb, 0x90, 0x5f, 0x9f, 0x4f, 0x9f, 0x3c, 0x1e, 0x30, 0x7f, 0x69, 0x99, 0xf2, 0xf8, 0x43,
	0xf5, 0xfe, 0x58, 0x55, 0xb9, 0x1e, 0xaa, 0xe7, 0xc5, 0xaa, 0xf5, 0xb6, 0xa1, 0x99, 0x0d, 0x78,
	0x15, 0x72, 0x12, 0x10, 0x97, 0x9c, 0x92, 0x8b, 0xc8, 0xaa, 0xf4, 0x9e, 0x41, 0x75, 0x38, 0x71,
	0x54, 0x8e, 0x13, 0xe7, 0xe1, 0x53, 0xab, 0xa2, 0x97, 0x47, 0x33, 0x9d, 0xf9, 0xc4, 0x39, 0x7a,
	0x68, 0x99, 0x7a, 0xf9, 0x68, 0x66, 0x55, 0xb3, 0xe5, 0x43, 0xab, 0xa6, 0x97, 0xe3, 0xd0, 0xaa,
	0xcb, 0x50, 0x86, 0x13, 0x67, 0x22, 0x7b, 0xc3, 0x6a, 0xf4, 0xee, 0xc3, 0xd6, 0xda, 0x6d, 0xcb,
	0xd4, 0x87, 0x2c, 0x5a, 0xa6, 0x27, 0x4c, 0xa3, 0x80, 0x0a, 0xcb, 0x18, 0xdc, 0x79, 0xf9, 0xdb,
	0x4e, 0xe5, 0xf2, 0x7a, 0xc7, 0x78, 0x79, 0xbd, 0x63, 0xfc, 0x7a, 0xbd, 0x63, 0xfc, 0xf8, 0xfb,
	0x4e, 0xe5, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x91, 0x38, 0xbc, 0x1c, 0xf7, 0x0b, 0x00, 0x00,
}
